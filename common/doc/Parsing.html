<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Parsing</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) krab5 2023</td></tr><tr><th>License</th><td>GPL-3</td></tr><tr><th>Maintainer</th><td>crab.delicieux@gmail.com</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Parsing</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This library implements a simple-yet-versatile form of parser combinators, represented basically
as state monads. Parsers are alternative monads, with <code>&lt;|&gt;</code> being the choice (alternative in a
grammar) and <code>&gt;&gt;=</code> being the sequencing of parsers.</p><p>The module also provides alternative functions and operators, for convenience. For instance,
<code><a href="Parsing.html#v:-37--62-" title="Parsing">%&gt;</a></code> and <code><a href="Parsing.html#v:-37-:-62-" title="Parsing">%:&gt;</a></code> exploit parsing results that are <code>MonadPlus</code> to parse and accumulate results
(which is very common when having repetitions, for instance).</p><p>The library has been made fairly generic, in particular in term of how the parsing result is
made. A &quot;default&quot; implementation uses the <code>Maybe</code> monad, which is good enough for simple parsing.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">newtype</span> <a href="#t:ParserT">ParserT</a> m s r = <a href="#v:ParserT">ParserT</a> {<ul class="subs"><li><a href="#v:runParserT">runParserT</a> :: s -&gt; m (s, r)</li></ul>}</li><li class="src short"><a href="#v:execParserT">execParserT</a> :: Functor m =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r -&gt; s -&gt; m r</li><li class="src short"><span class="keyword">type</span> <a href="#t:Parser">Parser</a> = <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> Maybe</li><li class="src short"><a href="#v:runParser">runParser</a> :: <a href="Parsing.html#t:Parser" title="Parsing">Parser</a> s r -&gt; s -&gt; Maybe (s, r)</li><li class="src short"><a href="#v:parserTOf">parserTOf</a> :: (s -&gt; m (s, r)) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r</li><li class="src short"><a href="#v:parserOf">parserOf</a> :: (s -&gt; Maybe (s, r)) -&gt; <a href="Parsing.html#t:Parser" title="Parsing">Parser</a> s r</li><li class="src short"><span class="keyword">class</span> <a href="#t:Stream">Stream</a> s <span class="keyword">where</span><ul class="subs"><li><a href="#v:uncons">uncons</a> :: s a -&gt; Maybe (a, s a)</li></ul></li><li class="src short"><a href="#v:done">done</a> :: <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s =&gt; s a -&gt; Bool</li><li class="src short"><a href="#v:failIf">failIf</a> :: Alternative m =&gt; (s -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s ()</li><li class="src short"><a href="#v:zero">zero</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a)</li><li class="src short"><a href="#v:end">end</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:jump">jump</a> :: Monad m =&gt; s -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s ()</li><li class="src short"><a href="#v:drop1">drop1</a> :: (<a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Alternative m) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:keep1">keep1</a> :: (<a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Alternative m, Applicative f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) (f a)</li><li class="src short"><a href="#v:notEmpty">notEmpty</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:parseAndBack">parseAndBack</a> :: Monad m =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r</li><li class="src short"><a href="#v:-37--62-">(%&gt;)</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a)</li><li class="src short"><a href="#v:-37-:-62-">(%:&gt;)</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a)</li><li class="src short"><a href="#v:parseP">parseP</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; (a -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) a</li><li class="src short"><a href="#v:parseP_">parseP_</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; (a -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:parseChar">parseChar</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Eq a) =&gt; a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) a</li><li class="src short"><a href="#v:parseChar_">parseChar_</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Eq a) =&gt; a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:parseSeq">parseSeq</a> :: (Monad m, Alternative m, Eq a, Foldable t, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, MonadPlus f) =&gt; t a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) (f a)</li><li class="src short"><a href="#v:parseSeq_">parseSeq_</a> :: (Monad m, Alternative m, Eq a, Foldable t, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; t a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) ()</li><li class="src short"><a href="#v:parseSpace">parseSpace</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) ()</li><li class="src short"><a href="#v:parseSpaces">parseSpaces</a> :: (Monad m, Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) ()</li><li class="src short"><a href="#v:parseDigit">parseDigit</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) Int</li><li class="src short"><a href="#v:parseNumber">parseNumber</a> :: (Monad m, Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) Int</li><li class="src short"><a href="#v:parseShow">parseShow</a> :: (Monad m, Alternative m, Show x, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; x -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) x</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:ParserT" class="def">ParserT</a> m s r <a href="#t:ParserT" class="selflink">#</a></p><div class="doc"><p>The main type for the parser, or parser &quot;transformer&quot;. The first type parameter (<code>m</code>) is the
 monad wrapping the parsing result. It should be some kind of alternative monad or <code>MonadFail</code> in 
 theory. This is not mandatory but will greatly impact the lib's usability.</p><p>The second type parameter (<code>s</code>) is the incoming stream. Once again, this could really be anything,
 although a number of convenient functions work on _stream-like_ inputs (see <code><a href="Parsing.html#t:Stream" title="Parsing">Stream</a></code> typeclass).</p><p>Last, the third type parameter (<code>r</code>) is the type of the outgoing result. This is the type that varies
 the most and for which <code><a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a></code> is a well-behave monad.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ParserT" class="def">ParserT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:runParserT" class="def">runParserT</a> :: s -&gt; m (s, r)</dfn><div class="doc"><p>Unwrap the parser, i.e. runs it</p></div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ParserT">Instances</h4><details id="i:ParserT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParserT:MonadFail:1"></span> MonadFail m =&gt; MonadFail (<a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s)</span> <a href="#t:ParserT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParserT:MonadFail:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fail">fail</a> :: String -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParserT:Alternative:2"></span> (Monad m, Alternative m) =&gt; Alternative (<a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s)</span> <a href="#t:ParserT" class="selflink">#</a></td><td class="doc"><p><code>Alternative</code> instance for the parser. </p></td></tr><tr><td colspan="2"><details id="i:id:ParserT:Alternative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p><p class="src"><a href="#v:some">some</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s [a]</p><p class="src"><a href="#v:many">many</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s [a]</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParserT:Applicative:3"></span> Monad m =&gt; Applicative (<a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s)</span> <a href="#t:ParserT" class="selflink">#</a></td><td class="doc"><p><code>Applicative</code> instance for the parser. </p></td></tr><tr><td colspan="2"><details id="i:id:ParserT:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (a -&gt; b) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b</p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s c</p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b</p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParserT:Functor:4"></span> Functor m =&gt; Functor (<a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s)</span> <a href="#t:ParserT" class="selflink">#</a></td><td class="doc"><p><code>Functor</code> instance for the parser, straightforward</p></td></tr><tr><td colspan="2"><details id="i:id:ParserT:Functor:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b</p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParserT:Monad:5"></span> Monad m =&gt; Monad (<a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s)</span> <a href="#t:ParserT" class="selflink">#</a></td><td class="doc"><p><code>Monad</code> instance for the parser.</p></td></tr><tr><td colspan="2"><details id="i:id:ParserT:Monad:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; (a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b</p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s b</p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a</p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:execParserT" class="def">execParserT</a> :: Functor m =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r -&gt; s -&gt; m r <a href="#v:execParserT" class="selflink">#</a></p><div class="doc"><p>Execute the parser, i.e. run it and keep only the result (if available). Note that no verification
 is done as if there is still stream to be parsed. A good grammar should explicitly have a starting
 rule with a <code><a href="Parsing.html#v:end" title="Parsing">end</a></code> or similar terminal, indicating the end of stream.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Parser" class="def">Parser</a> = <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> Maybe <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>Type synonym for parsers which wrapping monad is <code>Maybe</code>.</p></div></div><div class="top"><p class="src"><a id="v:runParser" class="def">runParser</a> :: <a href="Parsing.html#t:Parser" title="Parsing">Parser</a> s r -&gt; s -&gt; Maybe (s, r) <a href="#v:runParser" class="selflink">#</a></p><div class="doc"><p>Run a parser with <code>Maybe</code> as its monad</p></div></div><div class="top"><p class="src"><a id="v:parserTOf" class="def">parserTOf</a> :: (s -&gt; m (s, r)) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r <a href="#v:parserTOf" class="selflink">#</a></p><div class="doc"><p>Create a parser from a function.</p></div></div><div class="top"><p class="src"><a id="v:parserOf" class="def">parserOf</a> :: (s -&gt; Maybe (s, r)) -&gt; <a href="Parsing.html#t:Parser" title="Parsing">Parser</a> s r <a href="#v:parserOf" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Parsing.html#v:parserTOf" title="Parsing">parserTOf</a></code> but specialized for parser with <code>Maybe</code></p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Stream" class="def">Stream</a> s <span class="keyword">where</span> <a href="#t:Stream" class="selflink">#</a></p><div class="doc"><p>A class representing a certain type of polymorphic data structure for which it is
 possible to get an element + the rest of the structure (presumably without the element).</p><p>This class effectively factorises anything that looks like a sequence (or a list). It 
 allows for a bit of flexibility when using parsers (rather than using plain old lists).</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:uncons" class="def">uncons</a> :: s a -&gt; Maybe (a, s a) <a href="#v:uncons" class="selflink">#</a></p><div class="doc"><p>Takes the stream and try to extract an element and the remainder of the stream. If not possible,
 return <code>Nothing</code>.</p><p>This function returning <code>Nothing</code> implies that the stream is finished (end of string, end of file,
 etc.) or at least that no other character is available.</p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Stream">Instances</h4><details id="i:Stream" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Stream:Stream:1"></span> <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> List</span> <a href="#t:Stream" class="selflink">#</a></td><td class="doc"><p>Stream instance for lists (the most useful one)</p></td></tr><tr><td colspan="2"><details id="i:ic:Stream:Stream:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Parsing.html">Parsing</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:uncons">uncons</a> :: [a] -&gt; Maybe (a, [a]) <a href="#v:uncons" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:done" class="def">done</a> :: <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s =&gt; s a -&gt; Bool <a href="#v:done" class="selflink">#</a></p><div class="doc"><p>Tests if the stream is done, i.e. it is empty/no other symbol is available</p></div></div><div class="top"><p class="src"><a id="v:failIf" class="def">failIf</a> :: Alternative m =&gt; (s -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s () <a href="#v:failIf" class="selflink">#</a></p><div class="doc"><p>Parser that fails if the predicate is true on the given stream, and succeeds while consuming
 nothing otherwise.</p></div></div><div class="top"><p class="src"><a id="v:zero" class="def">zero</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) <a href="#v:zero" class="selflink">#</a></p><div class="doc"><p>Parser that always succeeds, consumes nothing and returns <code>mzero</code> in the provided <code>MonadPlus</code>
 instance. This is especially useful for repetition, i.e. :
 &gt; -- A -&gt; / (empty word)
 &gt; -- A -&gt; x A
 &gt; parseA = (parseChar <code>x</code> &gt;&gt;= x -&gt; parseA &gt;&gt;= xs -&gt; x <code>mplus</code> xs) <a href="|">|</a> zero</p></div></div><div class="top"><p class="src"><a id="v:end" class="def">end</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:end" class="selflink">#</a></p><div class="doc"><p>Parser that succeeds iff the stream has reach its end (and does not consume anything, subsequently).</p></div></div><div class="top"><p class="src"><a id="v:jump" class="def">jump</a> :: Monad m =&gt; s -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s () <a href="#v:jump" class="selflink">#</a></p><div class="doc"><p>Jump in the incoming stream, i.e. replace the current stream by another one. This is intended for
 redirections during parsing, and especially resetting the incoming stream (when performing simple
 lookahead).</p><p>This parser always succeeds, consume nothing and returns ()</p></div></div><div class="top"><p class="src"><a id="v:drop1" class="def">drop1</a> :: (<a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Alternative m) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:drop1" class="selflink">#</a></p><div class="doc"><p>Drop a symbol of the stream. This parser fails if the stream is done.</p></div></div><div class="top"><p class="src"><a id="v:keep1" class="def">keep1</a> :: (<a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Alternative m, Applicative f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) (f a) <a href="#v:keep1" class="selflink">#</a></p><div class="doc"><p>Consume one symbol of the stream and return it as result (as a <code>MonadPlus</code>). Fails if the stream
 is done.</p><p>This is intended for &quot;transponder&quot;-type parsers, which rewrites the input stream on their output (after
 transformation). The result is a <code>MonadPlus</code> to allow to chain the <code><a href="Parsing.html#v:keep1" title="Parsing">keep1</a></code>. The result is usually a
 list as well in that case.</p></div></div><div class="top"><p class="src"><a id="v:notEmpty" class="def">notEmpty</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:notEmpty" class="selflink">#</a></p><div class="doc"><p>Parser that consumes nothing and fails if the stream is done/empty.</p></div></div><div class="top"><p class="src"><a id="v:parseAndBack" class="def">parseAndBack</a> :: Monad m =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s r <a href="#v:parseAndBack" class="selflink">#</a></p><div class="doc"><p>Parser combinator that runs the given parser and then sets back the stream where it
 was before parsing.</p><p>For instance, if the result of parsing `onexyz...` is `1` with remaining stream being `xyz...`, then
 using <code><a href="Parsing.html#v:parseAndBack" title="Parsing">parseAndBack</a></code> on this parser will yield the result `1` (result of the parser) but `onexyz...` as
 the remaining stream.</p></div></div><div class="top"><p class="src"><a id="v:-37--62-" class="def">(%&gt;)</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) <span class="fixity">infixr 3</span><span class="rightedge"></span> <a href="#v:-37--62-" class="selflink">#</a></p><div class="doc"><p>Convenient combinator for parsers which result is a <code>MonadPlus</code>, that chains the parsers and
 <code>mplus</code> their results.</p></div></div><div class="top"><p class="src"><a id="v:-37-:-62-" class="def">(%:&gt;)</a> :: (Monad m, MonadPlus f) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m s (f a) <span class="fixity">infixr 3</span><span class="rightedge"></span> <a href="#v:-37-:-62-" class="selflink">#</a></p><div class="doc"><p>Specific version of <code><a href="Parsing.html#v:-37--62-" title="Parsing">%&gt;</a></code> where the first argument is not wrapped in the <code>MonadPlus</code> (convenient
 for injecting an element in a list, typically).</p></div></div><div class="top"><p class="src"><a id="v:parseP" class="def">parseP</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; (a -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) a <a href="#v:parseP" class="selflink">#</a></p><div class="doc"><p>Parser that succeeds if the head of the stream satisfies the given predicate. If it does not or if
 the stream is done, it fails. This returns the consumed symbol.</p></div></div><div class="top"><p class="src"><a id="v:parseP_" class="def">parseP_</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; (a -&gt; Bool) -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:parseP_" class="selflink">#</a></p><div class="doc"><p>Same as <code>parserP</code> but ignores the parsed symbol (and returns <code>()</code>).</p></div></div><div class="top"><p class="src"><a id="v:parseChar" class="def">parseChar</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Eq a) =&gt; a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) a <a href="#v:parseChar" class="selflink">#</a></p><div class="doc"><p>Parser that succeeds if the head of the stream is the given symbol, and fails otherwise or if the
 stream is done.</p></div></div><div class="top"><p class="src"><a id="v:parseChar_" class="def">parseChar_</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, Eq a) =&gt; a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:parseChar_" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Parsing.html#v:parseChar" title="Parsing">parseChar</a></code> but drops the symbol and returns <code>()</code>.</p></div></div><div class="top"><p class="src"><a id="v:parseSeq" class="def">parseSeq</a> :: (Monad m, Alternative m, Eq a, Foldable t, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s, MonadPlus f) =&gt; t a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) (f a) <a href="#v:parseSeq" class="selflink">#</a></p><div class="doc"><p>Parser that succeeds if the first elements of the stream correspond to the given sequence of
 symbols. If the stream is empty (or not long enough) or if the sequence is not right, it fails.</p><p>The returned result correspond to each character of the sequence that was parsed successfully, wrapped
 in the <code>MonadPlus</code> result.</p></div></div><div class="top"><p class="src"><a id="v:parseSeq_" class="def">parseSeq_</a> :: (Monad m, Alternative m, Eq a, Foldable t, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; t a -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s a) () <a href="#v:parseSeq_" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Parsing.html#v:parseSeq" title="Parsing">parseSeq</a></code> but drops the result and only return <code>()</code>.</p></div></div><div class="top"><p class="src"><a id="v:parseSpace" class="def">parseSpace</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) () <a href="#v:parseSpace" class="selflink">#</a></p><div class="doc"><p>Parse exactly one blank space (and drop it).</p></div></div><div class="top"><p class="src"><a id="v:parseSpaces" class="def">parseSpaces</a> :: (Monad m, Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) () <a href="#v:parseSpaces" class="selflink">#</a></p><div class="doc"><p>Parse a sequence of blank spaces (at least one) and drop the result.</p></div></div><div class="top"><p class="src"><a id="v:parseDigit" class="def">parseDigit</a> :: (Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) Int <a href="#v:parseDigit" class="selflink">#</a></p><div class="doc"><p>Parse one digit and return the corresponding <code>Int</code>.</p></div></div><div class="top"><p class="src"><a id="v:parseNumber" class="def">parseNumber</a> :: (Monad m, Alternative m, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) Int <a href="#v:parseNumber" class="selflink">#</a></p><div class="doc"><p>Parse a full number (and return its value). A number in this parser is simply a sequence of
 digits with no further constraints. I do not think it works on hexadecimal numbers (?).</p></div></div><div class="top"><p class="src"><a id="v:parseShow" class="def">parseShow</a> :: (Monad m, Alternative m, Show x, <a href="Parsing.html#t:Stream" title="Parsing">Stream</a> s) =&gt; x -&gt; <a href="Parsing.html#t:ParserT" title="Parsing">ParserT</a> m (s Char) x <a href="#v:parseShow" class="selflink">#</a></p><div class="doc"><p>Parse a type based on its textual representation given by its <code>Show</code> typeclass intsance.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>